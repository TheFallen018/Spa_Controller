#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <CircularBuffer.hpp>
#include <WebServer.h>
#include <ElegantOTA.h>
#include "lut.h"

// which analog pin to connect
#define THERMISTORPIN 34
// how many samples to take and average, more takes longer
// but is more 'smooth'
// resistance at 25 degrees C
#define THERMISTORNOMINAL 10000
// temp. for nominal resistance (almost always 25 C)
#define TEMPERATURENOMINAL 25
// how many samples to take and average, more takes longer
// but is more 'smooth'
#define NUMSAMPLES 10
// The beta coefficient of the thermistor (usually 3000-4000)
#define BCOEFFICIENT 3800
// the value of the 'other' resistor
#define SERIESRESISTOR 10000

#define PUMP 13
#define EXTERNAL_HEATER 26
#define INTERNAL_HEATER 14
#define BLOWER 12
#define LED 27

WebServer server(80);

WiFiClient espClient;
PubSubClient client(espClient);

char *mqtt_topic = "spa_controller";

char *mqtt_spa_available = "spa/available";
char *mqtt_spa_state = "spa/state";
char *mqtt_spa_set = "spa/set";

char *mqtt_spa_standby_warming_state = "spa/standby_warming/state";
char *mqtt_spa_standby_warming_set = "spa/standby_warming/set";

char *mqtt_spa_fast_heating_state = "spa/fast_heating/state";
char *mqtt_spa_fast_heating_set = "spa/fast_heating/set";

char *mqtt_spa_blower_state = "spa/blower/state";
char *mqtt_spa_blower_set = "spa/blower/set";

char *mqtt_spa_temperature_state = "spa/temperature/state";
char *mqtt_spa_temperature_set = "spa/temperature/set";
// char* mqtt_spa_temperature_target = "spa/temperature/target";
char *mqtt_debug_state = "spa/debug";

bool spa_state = false;
bool standby_warming_state = false;
bool fast_heating_state = false;
bool blower_state = false;
float temperature_target = 43.0;
float temperature_tolerance = 0.2;
float standby_tolerance = 2;
float standby_temp_delta = 2;

CircularBuffer<int, 10> circ_buffer;

int samples[NUMSAMPLES];

char buffer[256];
char callback_buffer[256];

uint8_t i;
float average = 0.0;
float defined_temp;

int period = 1000;
unsigned long temperature_loop_time = 0;
unsigned long mqtt_online_loop_time = 0;
JsonDocument doc;
float temperature = 0.0;

float get_temp()
{

  // take N samples in a row, with a slight delay
  for (i = 0; i < NUMSAMPLES; i++)
  {
    samples[i] = analogRead(THERMISTORPIN);
    delay(10);
  }

  // average all the samples out
  average = 0;
  for (i = 0; i < NUMSAMPLES; i++)
  {
    average += samples[i];
  }
  average /= NUMSAMPLES;
  average = ADC_LUT[int(average)];

  // Serial.print("Average analog reading ");
  // Serial.println(average);
  client.publish(mqtt_debug_state, ("ADC after LUT: " + String(average, 4)).c_str());

  // convert the value to resistance
  // average = 4095 / average - 1;
  client.publish(mqtt_debug_state, ("Average after to resistance " + String(average, 4)).c_str());
  // Send debug info: pre-resistance conversion value

  float v_out = average / 4095.0 * 3.3;
  float thermistor_resistance = SERIESRESISTOR * ((3.3 / v_out) - 1);

  // Debug: thermistor resistance
  client.publish(mqtt_debug_state, ("Thermistor resistance: " + String(thermistor_resistance, 2) + " ohms").c_str());

  // Calculate temperature
  float steinhart;
  steinhart = thermistor_resistance / THERMISTORNOMINAL; // (R/Ro)
  steinhart = log(steinhart);                            // ln(R/Ro)
  steinhart /= BCOEFFICIENT;                             // 1/B * ln(R/Ro)
  steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15);      // + (1/To)
  steinhart = 1.0 / steinhart;                           // Invert
  steinhart -= 273.15;                                   // convert absolute temp to C

  // Final temp debug
  String temp_str = String(steinhart, 2);
  client.publish(mqtt_debug_state, ("Calculated temp: " + temp_str + " C").c_str());

  defined_temp = defined_temp / 2 + steinhart / 2;
  circ_buffer.push(steinhart);
  float larger_average = 0;
  for (int i = 0; i < 10; i++)
  {
    larger_average += circ_buffer[i];
  }
  // defined_temp = larger_average/10;

  return larger_average / 10;
}

void setup()
{
  // put your setup code here, to run once:  uint8_t i;
  float average = 0.0;
  pinMode(PUMP, OUTPUT);
  pinMode(EXTERNAL_HEATER, OUTPUT);
  pinMode(INTERNAL_HEATER, OUTPUT);
  pinMode(BLOWER, OUTPUT);
  digitalWrite(PUMP, LOW);
  digitalWrite(EXTERNAL_HEATER, LOW);
  digitalWrite(INTERNAL_HEATER, LOW);
  digitalWrite(BLOWER, LOW);

  Serial.begin(115200);
  char *wifi_ssid = "2.4G-Tower";
  char *wifi_password = "Network_Layer";

  char *mqtt_broker = "192.168.0.180";

  char *mqtt_username = "mqtt_user";
  char *mqtt_password = "mqtt_user";
  int mqtt_port = 1883;

  setup_WiFi(wifi_ssid, wifi_password);
  setup_MQTT(mqtt_broker, mqtt_port, mqtt_username, mqtt_password, mqtt_topic);

  ElegantOTA.begin(&server); // Start ElegantOTA
  server.begin();
  Serial.println("HTTP server started");
  server.on("/", HTTP_GET, [&]() {
    String html = "<html><head><title>ESP32 Spa Controller</title>";
    html += "<meta http-equiv='refresh' content='5'>"; // Auto-refresh every 5 seconds
    html += "<style>"
            "body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }"
            "h1, h2 { color: #0056b3; }"
            "a { color: #007bff; text-decoration: none; font-size: 1.2em; }"
            "a:hover { text-decoration: underline; }"
            "table { width: 60%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }"
            "th, td { padding: 12px; border: 1px solid #ddd; text-align: left; }"
            "th { background-color: #007bff; color: white; }"
            ".state-on, .state-high { color: #28a745; font-weight: bold; }"
            ".state-off, .state-low { color: #dc3545; font-weight: bold; }"
            "</style></head><body>";

    html += "<h1>ESP32 Spa Controller Status</h1>";
    html += "<p><a href='/update'>» Go to Firmware Update Page</a></p>";

    // --- Current Spa States ---
    html += "<h2>Controller States</h2>";
    html += "<table>";
    html += "<tr><th>Parameter</th><th>State</th></tr>";
    html += "<tr><td>Spa Power</td><td><span class='state-" + String(spa_state ? "on" : "off") + "'>" + bool_to_str(spa_state) + "</span></td></tr>";
    html += "<tr><td>Standby Warming</td><td><span class='state-" + String(standby_warming_state ? "on" : "off") + "'>" + bool_to_str(standby_warming_state) + "</span></td></tr>";
    html += "<tr><td>Fast Heating</td><td><span class='state-" + String(fast_heating_state ? "on" : "off") + "'>" + bool_to_str(fast_heating_state) + "</span></td></tr>";
    html += "<tr><td>Blower</td><td><span class='state-" + String(blower_state ? "on" : "off") + "'>" + bool_to_str(blower_state) + "</span></td></tr>";
    html += "</table>";

    // --- Temperature Info ---
    html += "<h2>Temperature</h2>";
    html += "<table>";
    html += "<tr><th>Parameter</th><th>Value</th></tr>";
    html += "<tr><td>Current Temperature</td><td>" + String(temperature, 2) + " °C</td></tr>";
    html += "<tr><td>Target Temperature</td><td>" + String(temperature_target, 2) + " °C</td></tr>";
    html += "</table>";

    // --- GPIO Output States ---
    html += "<h2>GPIO Output States</h2>";
    html += "<table>";
    html += "<tr><th>Device</th><th>GPIO Pin</th><th>State</th></tr>";
    html += "<tr><td>PUMP</td><td>" + String(PUMP) + "</td><td><span class='state-" + String(digitalRead(PUMP) ? "high" : "low") + "'>" + String(digitalRead(PUMP) ? "HIGH" : "LOW") + "</span></td></tr>";
    html += "<tr><td>EXTERNAL_HEATER</td><td>" + String(EXTERNAL_HEATER) + "</td><td><span class='state-" + String(digitalRead(EXTERNAL_HEATER) ? "high" : "low") + "'>" + String(digitalRead(EXTERNAL_HEATER) ? "HIGH" : "LOW") + "</span></td></tr>";
    html += "<tr><td>INTERNAL_HEATER</td><td>" + String(INTERNAL_HEATER) + "</td><td><span class='state-" + String(digitalRead(INTERNAL_HEATER) ? "high" : "low") + "'>" + String(digitalRead(INTERNAL_HEATER) ? "HIGH" : "LOW") + "</span></td></tr>";
    html += "<tr><td>BLOWER</td><td>" + String(BLOWER) + "</td><td><span class='state-" + String(digitalRead(BLOWER) ? "high" : "low") + "'>" + String(digitalRead(BLOWER) ? "HIGH" : "LOW") + "</span></td></tr>";
    html += "</table>";

    html += "</body></html>";
    server.send(200, "text/html", html);
  });
}

void connect_wifi(const char *ssid, const char *password) {
  WiFi.setHostname("spa-controller");

  if (WiFi.status() == WL_CONNECTED) {
    return;
  }

  Serial.printf("Connecting to Wi-Fi: %s\n", ssid);
  WiFi.begin(ssid, password);

  unsigned long start_attempt_time = millis();
  const unsigned long timeout = 10000; // 10 seconds

  while (WiFi.status() != WL_CONNECTED && millis() - start_attempt_time < timeout) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConnected to Wi-Fi");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nFailed to connect to Wi-Fi");
  }
}

void loop()
{
  connect_wifi("2.4G-Tower", "Network_Layer");


  if (!client.connected())
  {
    Serial.println("MQTT lost. Reconnecting...");
    //setup_MQTT("192.168.0.180", 1883, "mqtt_user", "mqtt_user", mqtt_topic);
    setup_MQTT("192.168.0.180", 1883, "homeassistant", "theeng1sualeNg8iexeethah4jongieJou8xu9aich8eimogh2aengo8ciet0tiL", mqtt_topic);
  }

  client.loop();
  server.handleClient();

  ElegantOTA.loop();
  // Publish device online
  if (millis() > mqtt_online_loop_time + 60000)
  {
    mqtt_online_loop_time = millis();
    client.publish(mqtt_spa_available, "online");

    update_states();
  }

  // Get temperature
  if (millis() > temperature_loop_time + 5000)
  {
    temperature_loop_time = millis();
    if (temperature == 0.0)
    {
      temperature = get_temp();
    }
    else
    {
      temperature = temperature * 0.8 + get_temp() * 0.2;
    }
    doc.clear();
    doc["temperature"] = temperature;
    serializeJson(doc, buffer);
    client.publish(mqtt_spa_temperature_state, buffer);
  }
}

void setup_MQTT(char *broker, int port, char *username, char *password, char *topic)
{
  // connecting to a mqtt broker
  client.setServer(broker, port);
  client.setCallback(callback);
  while (!client.connected())
  {
    String client_id = "spa_controller-client-";
    client_id += String(WiFi.macAddress());
    Serial.printf("The client %s is attempting to connect to HomeAssistant MQTT\n", client_id.c_str());
    if (client.connect(client_id.c_str(), username, password))
    {
      Serial.println("HomeAssistant MQTT broker connected");
    }
    else
    {
      Serial.print("failed with state ");
      Serial.print(client.state());
      Serial.println("");
      delay(10000);
    }
  }

  client.subscribe(mqtt_spa_blower_set);
  client.subscribe(mqtt_spa_fast_heating_set);
  client.subscribe(mqtt_spa_standby_warming_set);
  client.subscribe(mqtt_spa_set);
  client.subscribe(mqtt_spa_temperature_set);
}

void callback(char *topic, byte *payload, unsigned int length)
{
  Serial.print("Message arrived in topic: ");
  Serial.println(topic);
  Serial.print("Message:");
  int i;
  for (i = 0; i < length; i++)
  {
    doc.clear();

    Serial.print((char)payload[i]);
    callback_buffer[i] = (char)payload[i];
  }

  // Handle cases
  bool set_on = is_on(callback_buffer);
  if (strcmp(topic, mqtt_spa_set) == 0)
  {
    spa_state = set_on;
  }
  else if (strcmp(topic, mqtt_spa_fast_heating_set) == 0)
  {
    fast_heating_state = set_on;
  }
  else if (strcmp(topic, mqtt_spa_standby_warming_set) == 0)
  {
    standby_warming_state = set_on;
  }
  else if (strcmp(topic, mqtt_spa_blower_set) == 0)
  {
    blower_state = set_on;
  }
  else if (strcmp(topic, mqtt_spa_temperature_set) == 0)
  {
    callback_buffer[length] = '\0';             // Null-terminate the buffer
    temperature_target = atof(callback_buffer); // Convert to float
  }
  update_states();
  if (startsWith(callback_buffer, "ON"))
  {
    Serial.println(" message on");
  }
  Serial.println();
  Serial.println("-----------------------");
}

bool is_on(char *callback_buffer)
{
  if (startsWith(callback_buffer, "ON"))
  {
    return true;
  }
  return false;
}

void setup_WiFi(char *ssid, char *password)
{
  WiFi.setHostname("spa-controller");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.println("Connecting to WiFi..");
  }
  Serial.println("Connected to the Wi-Fi network");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void update_mqtt_states()
{
  client.publish(mqtt_spa_state, bool_to_str(spa_state));
  client.publish(mqtt_spa_standby_warming_state, bool_to_str(standby_warming_state));
  client.publish(mqtt_spa_fast_heating_state, bool_to_str(fast_heating_state));
  client.publish(mqtt_spa_blower_state, bool_to_str(blower_state));
}

void update_state(char *topic, bool state)
{
  client.publish(topic, bool_to_str(state));
}

void update_states()
{
  update_mqtt_states();

  if (spa_state)
  {
    float current_target_temperature = temperature_target;
    float current_temperature_tolerance = temperature_tolerance;
    
    if (standby_warming_state) {
        current_target_temperature = temperature_target+standby_temp_delta;
        current_temperature_tolerance = standby_tolerance;
    }
    
    if (temperature > current_target_temperature + current_temperature_tolerance)
      {
      Serial.println("Temperature too high");

      // Temperature too high
      if (standby_warming_state)
      {
        digitalWrite(PUMP, LOW);
      }
      else
      {
        digitalWrite(PUMP, HIGH); // pump on if not standby
      }

      digitalWrite(INTERNAL_HEATER, LOW);
      digitalWrite(EXTERNAL_HEATER, LOW);
    }
    else if (temperature < current_target_temperature - current_temperature_tolerance)
      {
      Serial.println("Temperature too low");

      digitalWrite(PUMP, HIGH); // always on if too cold

      // Internal heater only if fast heating
      if (fast_heating_state)
      {
        digitalWrite(INTERNAL_HEATER, HIGH);
      }
      else
      {
        digitalWrite(INTERNAL_HEATER, LOW);
      }
      // External heater always on if temperature too low
      digitalWrite(EXTERNAL_HEATER, HIGH);
    }
    else
    {
      // Temperature within acceptable range — optional behavior
      Serial.println("Temperature OK");
      digitalWrite(PUMP, HIGH);
      digitalWrite(INTERNAL_HEATER, LOW);
      digitalWrite(EXTERNAL_HEATER, LOW);
    }

    // Blower state
    if (blower_state)
    {
      digitalWrite(BLOWER, HIGH);
    }
    else
    {
      digitalWrite(BLOWER, LOW);
    }
  }
  else
  {
    // Spa is OFF
    digitalWrite(PUMP, LOW);
    digitalWrite(INTERNAL_HEATER, LOW);
    digitalWrite(EXTERNAL_HEATER, LOW);
    digitalWrite(BLOWER, LOW);
  }

  // Print current states
  Serial.println("=== Current Spa States ===");
  Serial.printf("Spa State: %s\n", spa_state ? "ON" : "OFF");
  Serial.printf("Standby Warming: %s\n", standby_warming_state ? "ON" : "OFF");
  Serial.printf("Fast Heating: %s\n", fast_heating_state ? "ON" : "OFF");
  Serial.printf("Blower: %s\n", blower_state ? "ON" : "OFF");
  Serial.printf("Temperature: %.2f°C\n", temperature);
  Serial.printf("Target Temperature: %.2f°C\n", temperature_target);
  Serial.printf("Temperature Tolerance: %.2f°C\n", temperature_tolerance);

  // Read and print GPIO output states
  Serial.println("--- GPIO Output States ---");
  Serial.printf("PUMP (GPIO %d): %s\n", PUMP, digitalRead(PUMP) ? "HIGH" : "LOW");
  Serial.printf("EXTERNAL_HEATER (GPIO %d): %s\n", EXTERNAL_HEATER, digitalRead(EXTERNAL_HEATER) ? "HIGH" : "LOW");
  Serial.printf("INTERNAL_HEATER (GPIO %d): %s\n", INTERNAL_HEATER, digitalRead(INTERNAL_HEATER) ? "HIGH" : "LOW");
  Serial.printf("BLOWER (GPIO %d): %s\n", BLOWER, digitalRead(BLOWER) ? "HIGH" : "LOW");
  Serial.println("==========================");
}

char *bool_to_str(bool state)
{
  if (state)
  {
    return "ON";
  }
  return "OFF";
}

bool startsWith(const char *str, const char *prefix)
{
  return strncmp(str, prefix, strlen(prefix)) == 0;
}